from dotenv import load_dotenv
import os

load_dotenv()  # loads DATABASE_URL from .env

# -*- coding: utf-8 -*-
"""Flask Portal Server (PostgreSQL Integration)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UuCgb5tAyG4Rc2CPc0W2014TT2kylQ6R
"""

import os
import logging
import uuid
from flask import Flask, jsonify, request, g, abort, render_template

# Import the new PostgreSQL connection pool handlers
from db_connection import setup_db_pool, get_db_connection, return_db_connection, shutdown_db_pool

# --- Configuration and Initialization ---
app = Flask(__name__)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- Database Setup and Teardown ---

@app.before_request
def before_request():
    """
    Acquire a database connection from the pool and store it in Flask's 'g' object.
    This ensures the connection is available for the duration of the request.
    """
    # Lazily set up the pool if it hasn't been done yet (primarily for initial run)
    try:
        if not hasattr(g, 'db_conn'):
            g.db_conn = get_db_connection()
    except RuntimeError as e:
        logger.error(f"Failed to acquire database connection: {e}")
        # Abort the request if the DB is unreachable
        abort(503, description="Database service unavailable.")


@app.teardown_request
def teardown_request(exception=None):
    """
    Return the database connection to the pool after the request is finished.
    """
    conn = g.pop('db_conn', None)
    if conn is not None:
        return_db_connection(conn)

# --- PostgreSQL Data Access Functions ---

def get_product_details(product_id):
    """
    Fetches details for a single product from the PostgreSQL 'products' table.

    (Conversion from SQLite complete)
    """
    conn = g.db_conn
    cursor = None
    try:
        cursor = conn.cursor()

        # PostgreSQL syntax: Use %s placeholders for parameter substitution
        sql = "SELECT id, name, price, description FROM products WHERE id = %s;"
        cursor.execute(sql, (product_id,))

        row = cursor.fetchone()

        if row:
            return {
                'id': row[0],
                'name': row[1],
                'price': float(row[2]),
                'description': row[3]
            }
        return None

    except Exception as e:
        # In case of error, rollback any potential transaction
        conn.rollback()
        logger.error(f"Error fetching product {product_id}: {e}")
        return None
    finally:
        if cursor:
            cursor.close()
        # conn is returned to the pool in teardown_request

def get_user_by_username(username: str):
    """
    Fetches user data by username for authentication.

    Assumes 'users' table has columns: id, username, hashed_password, tier.
    """
    conn = g.db_conn
    cursor = None
    user_data = None
    try:
        cursor = conn.cursor()

        # Select all columns needed for login/session
        sql = """
        SELECT id, username, hashed_password, tier
        FROM users
        WHERE username = %s;
        """
        cursor.execute(sql, (username,))

        row = cursor.fetchone()

        if row:
            user_data = {
                'id': row[0],
                'username': row[1],
                'hashed_password': row[2],
                'tier': row[3]
            }

    except Exception as e:
        conn.rollback()
        logger.error(f"Error fetching user {username}: {e}")
    finally:
        if cursor:
            cursor.close()

    return user_data

def create_new_user(username: str, hashed_password: str, tier: str = 'none') -> int | None:
    """
    [NEW POSTGRESQL FUNCTION] Inserts a new user and returns the new user's ID.

    Crucial PostgreSQL element: using 'RETURNING id' to get the primary key.
    """
    conn = g.db_conn
    cursor = None
    new_user_id = None

    try:
        cursor = conn.cursor()

        # 1. SQL for Insertion
        sql = """
        INSERT INTO users (username, hashed_password, tier)
        VALUES (%s, %s, %s)
        RETURNING id;
        """
        # 2. Execute and Fetch the new ID
        cursor.execute(sql, (username, hashed_password, tier))

        # 3. Commit the transaction to save the new user
        conn.commit()

        # 4. Retrieve the ID returned by the RETURNING clause
        new_user_id = cursor.fetchone()[0]

    except Exception as e:
        # Rollback the transaction if anything failed
        conn.rollback()
        # Note: Log a specific error if username already exists (psycopg2.errors.UniqueViolation)
        logger.error(f"Error creating user {username}: {e}")
        new_user_id = None
    finally:
        if cursor:
            cursor.close()

    return new_user_id


# --- Flask Routes ---

@app.route('/product/<int:product_id>', methods=['GET'])
def product_view(product_id):
    product = get_product_details(product_id)
    if product:
        return jsonify(product)
    return jsonify({"error": "Product not found"}), 404

@app.route('/auth/login', methods=['POST'])
def login_user():
    """
    A basic login route placeholder using the new PostgreSQL fetch function.
    (Password verification logic omitted for brevity, but this is where it would go)
    """
    data = request.json
    username = data.get('username')
    password = data.get('password') # The unhashed password from the user

    if not username or not password:
        return jsonify({"error": "Missing username or password"}), 400

    user = get_user_by_username(username)

    if user:
        # NOTE: In a real app, you must verify the password hash here
        # E.g., if bcrypt.checkpw(password, user['hashed_password']):

        # Placeholder success response
        return jsonify({
            "message": "Login successful (password check skipped)",
            "user_id": user['id'],
            "tier": user['tier']
        })

    return jsonify({"error": "Invalid credentials"}), 401

@app.route('/auth/register', methods=['POST'])
def register_user():
    """
    Handles user registration using the new PostgreSQL insert function.
    """
    data = request.json
    username = data.get('username')
    # NOTE: In a real app, you must hash the password before storing it.
    password_hash = data.get('password_hash', str(uuid.uuid4())) # Use a mock hash for now

    if not username or not password_hash:
        return jsonify({"error": "Missing required fields"}), 400

    # 1. Check if user already exists
    if get_user_by_username(username):
        return jsonify({"error": "Username already taken"}), 409

    # 2. Create the new user
    new_id = create_new_user(username, password_hash)

    if new_id:
        return jsonify({
            "message": "User registered successfully",
            "user_id": new_id,
            "username": username
        }), 201
    else:
        # Error logged in create_new_user function
        return jsonify({"error": "Failed to create user due to a database issue"}), 500

# --- Startup ---

# This handles the initial connection pool setup for the application.
if __name__ == '__main__':
    try:
        # Initialize the database connection pool right before running the app
        setup_db_pool()
        logger.info("Application starting with PostgreSQL Connection Pool.")

        # Flask runs in development mode here. Gunicorn runs the app in production.
        app.run(debug=True, port=int(os.environ.get('PORT', 5000)))

    except Exception as e:
        logger.critical(f"Fatal error during application startup: {e}")
        # Ensure the pool is shut down if startup fails
        shutdown_db_pool()