# -*- coding: utf-8 -*-
"""Flask Portal Server (PostgreSQL Integration)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rYfhVV8Yt_hWTjhQ9lRRs0bqJx7jfQDJ
"""

import os
import logging
import uuid
import psycopg2 # Import psycopg2 for specific error handling
# ⚡ NEW: Import for secure password hashing
from werkzeug.security import generate_password_hash, check_password_hash

from flask import Flask, jsonify, request, g, abort, render_template

# Import the new PostgreSQL connection pool handlers
from db_connection import setup_db_pool, get_db_connection, return_db_connection, shutdown_db_pool

# --- Configuration and Initialization ---
app = Flask(__name__)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- Database Setup and Teardown ---

@app.before_request
def before_request():
    """
    Acquire a database connection from the pool and store it in Flask's 'g' object.
    This ensures the connection is available for the duration of the request.
    """
    try:
        if not hasattr(g, 'db_conn'):
            g.db_conn = get_db_connection()
    except RuntimeError as e:
        logger.error(f"Failed to acquire database connection: {e}")
        # Abort the request if the DB is unreachable (e.g., connection pool error)
        abort(503, description="Database service unavailable.")


@app.teardown_request
def teardown_request(exception=None):
    """
    Return the database connection to the pool after the request is finished.
    """
    conn = g.pop('db_conn', None)
    if conn is not None:
        # Note: If conn.autocommit is False (as in db_connection.py),
        # any uncommitted transaction will be rolled back when returned to the pool.
        return_db_connection(conn)

# --- Database Initialization ---

def initialize_database_tables():
    """
    Creates necessary tables (users, products) if they do not already exist.
    This ensures a clean first-time deployment on the empty Railway database.
    """
    conn = None
    cursor = None
    try:
        # Get a temporary connection specifically for setup
        conn = get_db_connection()
        cursor = conn.cursor()

        # SQL to create the users table (adapted from setup_users.sql)
        # Note: Added 'hashed_password' column to match application logic
        users_table_sql = """
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE NOT NULL,
            hashed_password VARCHAR(255) NOT NULL,
            tier VARCHAR(50) DEFAULT 'none',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );
        """

        # SQL to create a sample products table
        products_table_sql = """
        CREATE TABLE IF NOT EXISTS products (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            price NUMERIC(10, 2) NOT NULL,
            description TEXT
        );
        """

        cursor.execute(users_table_sql)
        cursor.execute(products_table_sql)
        conn.commit()
        logger.info("[PostgreSQL] Tables initialized successfully.")

    except psycopg2.Error as e:
        if conn:
            conn.rollback()
        logger.critical(f"[PostgreSQL] Failed to initialize database tables: {e}")
        # Re-raise to prevent the app from starting with a broken DB schema
        raise
    finally:
        if cursor:
            cursor.close()
        if conn:
            # IMPORTANT: Return the temporary connection to the pool
            return_db_connection(conn)

# --- PostgreSQL Data Access Functions ---

def get_product_details(product_id):
    """
    Fetches details for a single product from the PostgreSQL 'products' table.
    """
    conn = g.db_conn
    cursor = None
    try:
        cursor = conn.cursor()

        # PostgreSQL syntax: Use %s placeholders for parameter substitution
        sql = "SELECT id, name, price, description FROM products WHERE id = %s;"
        cursor.execute(sql, (product_id,))

        row = cursor.fetchone()

        if row:
            return {
                'id': row[0],
                'name': row[1],
                'price': float(row[2]),
                'description': row[3]
            }
        return None

    except Exception as e:
        conn.rollback()
        logger.error(f"Error fetching product {product_id}: {e}")
        return None
    finally:
        if cursor:
            cursor.close()

def get_user_by_username(username: str):
    """
    Fetches user data by username for authentication.
    """
    conn = g.db_conn
    cursor = None
    user_data = None
    try:
        cursor = conn.cursor()

        # Select all columns needed for login/session
        sql = """
        SELECT id, username, hashed_password, tier
        FROM users
        WHERE username = %s;
        """
        cursor.execute(sql, (username,))

        row = cursor.fetchone()

        if row:
            user_data = {
                'id': row[0],
                'username': row[1],
                # Return the hashed password from the DB for verification
                'hashed_password': row[2],
                'tier': row[3]
            }

    except Exception as e:
        conn.rollback()
        logger.error(f"Error fetching user {username}: {e}")
    finally:
        if cursor:
            cursor.close()

    return user_data

def create_new_user(username: str, hashed_password: str, tier: str = 'none') -> int | None:
    """
    Inserts a new user and returns the new user's ID using PostgreSQL's 'RETURNING id'.
    """
    conn = g.db_conn
    cursor = None
    new_user_id = None

    try:
        cursor = conn.cursor()

        sql = """
        INSERT INTO users (username, hashed_password, tier)
        VALUES (%s, %s, %s)
        RETURNING id;
        """
        # Note: hashed_password must already be a hash (e.g., from generate_password_hash)
        cursor.execute(sql, (username, hashed_password, tier))

        # Commit the transaction to save the new user
        conn.commit()

        new_user_id = cursor.fetchone()[0]

    except psycopg2.errors.UniqueViolation:
        conn.rollback()
        logger.warning(f"Registration failed: Username '{username}' already exists.")
        return None
    except Exception as e:
        conn.rollback()
        logger.error(f"Error creating user {username}: {e}")
        new_user_id = None
    finally:
        if cursor:
            cursor.close()

    return new_user_id


# --- Flask Routes ---

@app.route('/product/<int:product_id>', methods=['GET'])
def product_view(product_id):
    product = get_product_details(product_id)
    if product:
        return jsonify(product)
    return jsonify({"error": "Product not found"}), 404

@app.route('/auth/login', methods=['POST'])
def login_user():
    """
    Handles user login, securely verifying the provided password against the stored hash.
    """
    data = request.json
    username = data.get('username')
    password = data.get('password') # Plain text password from user

    if not username or not password:
        return jsonify({"error": "Missing username or password"}), 400

    user = get_user_by_username(username)

    if user:
        # ⚡ NEW: Use werkzeug.security to verify the password hash
        if check_password_hash(user['hashed_password'], password):
            return jsonify({
                "message": "Login successful",
                "user_id": user['id'],
                "tier": user['tier']
            }), 200
        else:
            # Authentication failed (incorrect password)
            return jsonify({"error": "Invalid credentials"}), 401

    # User not found
    return jsonify({"error": "Invalid credentials"}), 401

@app.route('/auth/register', methods=['POST'])
def register_user():
    """
    Handles user registration, securely hashing the password before insertion.
    """
    data = request.json
    username = data.get('username')
    plain_password = data.get('password') # Plain text password from user

    if not username or not plain_password:
        return jsonify({"error": "Missing required fields"}), 400

    # ⚡ NEW: Securely hash the plain text password
    hashed_password = generate_password_hash(plain_password)

    new_id = create_new_user(username, hashed_password)

    if new_id:
        return jsonify({
            "message": "User registered successfully",
            "user_id": new_id,
            "username": username
        }), 201
    else:
        # If new_id is None, it means the username already existed or a DB error occurred.
        return jsonify({"error": "Username already taken or registration failed"}), 409

# --- Startup ---

# This handles the initial connection pool setup for the application.
if __name__ == '__main__':
    try:
        # 1. Initialize the database connection pool
        setup_db_pool()
        logger.info("Application starting with PostgreSQL Connection Pool.")

        # 2. Ensure tables exist before running
        initialize_database_tables()

        # Flask runs in development mode here. Gunicorn runs the app in production.
        app.run(debug=True, port=int(os.environ.get('PORT', 5000)))

    except Exception as e:
        logger.critical(f"Fatal error during application startup: {e}")
        # Ensure the pool is shut down if startup fails
        shutdown_db_pool()