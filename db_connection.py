# -*- coding: utf-8 -*-
"""PostgreSQL Database Connection Handler

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1drdf2Q1lNY2eAesLGX-tqXt4KEUnaaxc
"""

import os
import logging
from typing import Optional, Any
from urllib.parse import urlparse

# We use the connection pooling feature of psycopg2 for a production web app
import psycopg2.pool
import psycopg2

# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Global variable to hold the connection pool instance
_postgres_pool: Optional[psycopg2.pool.SimpleConnectionPool] = None
# Define the pool size constants
MIN_CONN = 1
MAX_CONN = 10

def setup_db_pool():
    """
    Initializes the PostgreSQL connection pool using the DATABASE_URL environment variable.
    This must be called once when the Flask application starts up.
    """
    global _postgres_pool

    # 1. Get the DATABASE_URL from Railway environment variables
    db_url = os.environ.get('DATABASE_URL')

    if not db_url:
        logger.error("DATABASE_URL environment variable not found. Cannot connect to PostgreSQL.")
        # Raise an error to stop deployment if credentials are missing
        raise RuntimeError("DATABASE_URL not set. Is the app deployed to Railway?")

    if _postgres_pool is None:
        try:
            # PostgreSQL connection pooling is much better for a concurrent web app
            # than a single global connection object.

            # 2. Parse the DATABASE_URL string to extract individual components for the pool
            # The psycopg2 pool uses individual arguments better than a DSN string sometimes.
            url = urlparse(db_url)

            _postgres_pool = psycopg2.pool.SimpleConnectionPool(
                minconn=MIN_CONN,
                maxconn=MAX_CONN,
                host=url.hostname,
                port=url.port,
                database=url.path[1:], # Remove leading '/'
                user=url.username,
                password=url.password
            )
            logger.info(f"[PostgreSQL] Connection Pool initialized (Min: {MIN_CONN}, Max: {MAX_CONN}).")

        except psycopg2.Error as e:
            logger.critical(f"[PostgreSQL] Connection Pool initialization failed: {e}")
            raise RuntimeError(f"Failed to initialize PostgreSQL Connection Pool: {e}")

    return _postgres_pool

def get_db_connection():
    """
    Acquires a database connection from the pool.
    This should be called at the beginning of any function that needs to query the database.
    """
    global _postgres_pool
    if _postgres_pool is None:
        # Attempt to set up the connection if it hasn't been done yet (or if called outside of app context)
        setup_db_pool()

    if _postgres_pool is None:
        raise RuntimeError("PostgreSQL connection pool is not established.")

    try:
        # Get a connection from the pool
        conn = _postgres_pool.getconn()
        conn.autocommit = False # Standard practice for transactions, commit/rollback manually
        return conn
    except psycopg2.Error as e:
        logger.error(f"[PostgreSQL] Failed to get connection from pool: {e}")
        raise RuntimeError(f"Could not acquire connection: {e}")


def return_db_connection(conn: Any):
    """
    Returns a database connection back to the pool.
    This must be called after a query function finishes, whether successfully or due to an error.
    """
    global _postgres_pool
    if _postgres_pool is not None and conn is not None:
        _postgres_pool.putconn(conn)


def shutdown_db_pool():
    """
    Closes all connections in the pool cleanly.
    This should be called when the Flask application shuts down.
    """
    global _postgres_pool
    if _postgres_pool is not None:
        try:
            _postgres_pool.closeall()
            logger.info("[PostgreSQL] Connection Pool closed.")
        except psycopg2.Error as e:
            logger.error(f"[PostgreSQL] Error closing pool connections: {e}")
        finally:
            _postgres_pool = None